@page "/dashboard"
@using Microsoft.AspNetCore.SignalR.Client
@using Planner.Application.Events
@using Planner.Hubs
@attribute [Authorize]
@inject GoalsRepository GoalsRepository
@inject JobsRepository JobsRepository
@inject ContractorsRepository ContractorsRepository
@inject NavigationManager NavigationManager
@inject IDispatcher Dispatcher
@implements IAsyncDisposable

<PageTitle>Dashboard</PageTitle>

<MudContainer Class="mt-4">
	<MudGrid>
		<MudItem md="0" lg="4">
			<MudTimeline>
				@foreach (JobsNotes notes in JobsNotes)
				{
					<MudTimelineItem>
						<ItemOpposite>
							<MudText Typo="Typo.body2">@notes.Date.ToString("D")</MudText>
						</ItemOpposite>
						<ItemContent>
							@foreach (JobsNote note in notes.Notes)
							{
								<MudCard>
									<MudCardHeader>
										<MudStack Row Spacing="30">
											<MudText Typo="Typo.body2">@note.Name</MudText>
											<MudText Typo="Typo.body2">@note.Time.ToString(UserSettings.TimeFormatterValue(UserSettings))</MudText>
										</MudStack>
										
									</MudCardHeader>
									<MudCardContent>
										<MudText Typo="Typo.body2">@note.Comment</MudText>
									</MudCardContent>
								</MudCard>
							}
						</ItemContent>
					</MudTimelineItem>
				}
			</MudTimeline>
		</MudItem>

		<MudItem xs="12" lg="8">
			<MudPaper Class="p-4">
				<MudStack Row>
					<MudTextField Class="pl-2" T="string" Label="Name" @bind-Value="GoalName" Clearable/>
					<MudButton Variant="Variant.Filled" OnClick="Store">Add</MudButton>
				</MudStack>
			</MudPaper>

			<MudTable Class="w-full my-12" T="ActiveGoal" Items="@Goals" Hover Dense FixedHeader Breakpoint="Breakpoint.None"
			          CanCancelEdit RowEditCommit="CommitRowEdit" RowEditPreview="BackupRowEdit" RowEditCancel="CancelRowEdit">
				<HeaderContent>
					<MudTh>Contractor</MudTh>
					<MudTh>Elapsed</MudTh>
					<MudTh>Name</MudTh>
					<MudTh>
						<MudStack Row Justify="Justify.FlexEnd" AlignItems="AlignItems.Center">
							<MudButtonGroup Size="Size.Small" Variant="Variant.Outlined" VerticalAlign>
								<MudButton OnClick="CompleteJob">Complete</MudButton>
							</MudButtonGroup>
						</MudStack>
					</MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd DataLabel="Contractor">@(context.Contractor?.Name ?? string.Empty)</MudTd>
					<MudTd DataLabel="Elapsed">@context.ElapsedTimeTotal.ToString(UserSettings.TimeFormatterValue(UserSettings))</MudTd>
					<MudTd DataLabel="Name">@context.Name.Clamp(100)</MudTd>
					<MudTd DataLabel="Buttons">
						<MudStack Row Justify="Justify.FlexEnd" AlignItems="AlignItems.Center">
							<MudText Typo="Typo.button" Style="line-height: 20px">@context.ElapsedTime.ToString(UserSettings.DetailedTimeFormatterValue(UserSettings))</MudText>
							<MudToggleIconButton ToggledChanged="e => SwitchTimer(e, context)" Toggled="@context.Tick" Icon="@Icons.Material.Filled.PlayArrow" ToggledIcon="@Icons.Material.Filled.Stop"/>
							<MudIconButton Icon="@Icons.Material.Filled.Delete" @onclick="() => Destroy(context)"/>
							<MudIconButton Icon="@Icons.Material.Filled.OpenInNew" Href="@($"/goals/{context.Id}/edit")"/>
						</MudStack>
					</MudTd>
				</RowTemplate>
				<RowEditingTemplate>
					<MudTd DataLabel="Contractor">
						<MudSelect T="Contractor" Label="Contractor" @bind-Value="context.Contractor" Dense Variant="Variant.Filled" AnchorOrigin="Origin.BottomCenter">
							<MudSelectItem Value="Contractor.Empty"/>
							@foreach (var item in Contractors)
							{
								<MudSelectItem Value="item"/>
							}
						</MudSelect>
					</MudTd>
					<MudTd DataLabel="ElapsedTime">@context.ElapsedTimeTotal.ToString(UserSettings.TimeFormatterValue(UserSettings))</MudTd>
					<MudTd DataLabel="Name">
						<MudTextField T="string" Label="Name" @bind-Value="context.Name" Immediate Clearable Variant="Variant.Filled"/>
					</MudTd>
				</RowEditingTemplate>
			</MudTable>
		</MudItem>
	</MudGrid>
</MudContainer>

@code {
	private HubConnection? _hubConnection;

	[CascadingParameter]
	public MainLayout? Layout { get; set; }
	public User? User => Layout?.User;
	public UserSettings? UserSettings => Layout?.UserSettings;

	private Goal? Goal { get; set; } = new();
	public List<ActiveGoal> Goals { get; set; } = new();
	public string GoalName { get; set; } = string.Empty;
	public List<Contractor> Contractors { get; set; } = new();
	private GoalRowEditForm _goalBackup = new();
	private List<JobsNotes> JobsNotes { get; set; } = new();

	protected override async Task OnInitializedAsync()
	{
		Contractors = await ContractorsRepository.List();

		_hubConnection = new HubConnectionBuilder()
			.WithUrl(NavigationManager.ToAbsoluteUri("/hubs/timers"))
			.Build();
		_hubConnection.On<int, int, TimeSpan>(nameof(ITimers.Tick), (id, userId, elapsedTime) =>
		{
			if (User?.Id != userId) return;
			ActiveGoal? goal = Goals.Find(x => x.ElapsedTimePartId == id);
			if (goal is null) return;
			goal.ElapsedTime = elapsedTime;
			InvokeAsync(StateHasChanged);
		});
		_hubConnection.On<int, ActiveGoal>(nameof(ITimers.GoalChanged), (userId, data) =>
		{
			if (User?.Id != userId) return;
			ActiveGoal? goal = Goals.Find(x => x.Id == data.Id);
			if (goal is null) return;
			goal.Copy(data);
			InvokeAsync(StateHasChanged);
		});
		_hubConnection.On<int, int, TimeSpan>(nameof(ITimers.GoalTimeChanged), (userId, goalId, time) =>
		{
			if (User?.Id != userId) return;
			ActiveGoal? goal = Goals.Find(x => x.Id == goalId);
			if (goal is null) return;
			goal.ElapsedTimeTotal = time;
			InvokeAsync(StateHasChanged);
		});
		_hubConnection.On<int, JobsNotes>(nameof(ITimers.JobBuild), (userId, notes) =>
		{
			if (User?.Id != userId) return;
			Goals.ForEach(x =>
			{
				x.ElapsedTime = TimeSpan.Zero;
				x.ElapsedTimePartId = 0;
				x.Tick = false;
			});
			JobsNotes.Insert(0, notes);
			InvokeAsync(StateHasChanged);
		});

		await _hubConnection.StartAsync();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			if (User is null) return;
			Goals = await GoalsRepository.List(User);
			JobsNotes = await JobsRepository.List(User.Id);
			StateHasChanged();
		}
	}
	
	private async Task Destroy(ActiveGoal entity)
	{
		await GoalsRepository.Destroy(entity.Id);
		Goals.Remove(entity);
	}


	private void ShowBtnPress(ActiveGoal context)
	{
		context.ShowParts = !context.ShowParts;
	}
	
	public async ValueTask DisposeAsync()
	{
		if (_hubConnection is not null) await _hubConnection.DisposeAsync();
	}

	private async Task Store()
	{
		ActiveGoal goal = await GoalsRepository.Store(GoalName, User?.Id ?? 0, DateTime.UtcNow);
		Goals.Insert(0, goal);
	}

	private async void CommitRowEdit(object item)
	{
		if (item is not ActiveGoal goal) return;
		await Dispatcher.Broadcast(new GoalChanged()
		{
				Id = goal.Id,
				Name = goal.Name,
				Contractor = goal.Contractor,
				Comment = goal.Comment,
				UserId = User!.Id,
				UpdatedAt = DateTime.Now
		});
	}
	private void BackupRowEdit(object item)
	{
		if (item is not ActiveGoal goal) return;
		_goalBackup.Fill(goal);
	}
	private void CancelRowEdit(object item)
	{
		if (item is not ActiveGoal goal) return;
		goal.Name = _goalBackup.Name;
		goal.Contractor = _goalBackup.Contractor;
	}

	private async Task SwitchTimer(bool enable, ActiveGoal activeGoal)
	{
		if (_hubConnection is null) return;
		if (enable)
		{
			var data = await _hubConnection.InvokeAsync<int>(nameof(ITimers.ActivateTimer), activeGoal.Id, User!.Id, DateTime.Now);
			activeGoal.ElapsedTimePartId = data;
			activeGoal.Tick = true;
		}
		else
		{
			var data = await _hubConnection.InvokeAsync<TimeSpan>(nameof(ITimers.StopTimer), activeGoal.ElapsedTimePartId, User!.Id, DateTime.Now);
			activeGoal.ElapsedTime = data;
			activeGoal.Tick = false;
		}
	}

	private class GoalRowEditForm
	{
		public ActiveGoal? Source { get; set; }
		public int Id { get; set; }
		public Contractor? Contractor { get; set; }
		public string Name { get; set; } = string.Empty;
		public string Comment { get; set; } = string.Empty;

		public void Fill(ActiveGoal data)
		{
			Id = data.Id;
			Contractor = data.Contractor;
			Name = data.Name;
			Comment = data.Comment;
		}
	}

	private async Task CompleteJob()
	{
		await Dispatcher.Broadcast(new JobBuildRequested()
		{
			RequestedAt = DateTime.Now,
			UserId = User!.Id
		});
	}

}
